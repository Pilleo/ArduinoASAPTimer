/*This my pattern for executing some periodic actions on Arduino. 
It is not always faster and ram lighter than millis() and micros() patterns but it may be more convenient in some ways too.
That may be used for debouncing. My sketch is running every loop() at least 20 ms, and if i am using 5 ms time to wait to
debount a button, it will still be at least ms waiting, also cpu will have to compare two not zero values, which is a bit slower.
That is more difficult for cpu than just incrementing and decrementing one variable and comparing it
to 0. 
It is convenient in cases, when you dont care when exactly task will be done, you just want it to be done ASAP (as soon as possinle), but
not during that particular iteration of loop(). Basicly you can use it as a timer if you know how it takes one iteration to be done.
So, if your sketch runs 1 iteration of loop() for 1 ms, and you need some action to be done every 1 sec, 1ms*1000 == 1 sec. So you
need it to be done every 1000 iterations. 
Please learn about millis(), micros(), hardware timers before using that. If your code works good now, i guess it will not be useful for you. 
If you have ideas, benchmarks of that code or critics - please write it, i will be happy to learn or know that it helped you. 
*/

boolean onOff=1; // arduino led state. My task here is LED blinking.
byte counter=2; // number of iterations made by loop(). Set as little variable as possible to save ram and cpu time. 
// Your code will be executed every "counter" iteration of loop(). 
void setup() {
  pinMode(13, OUTPUT);
}

void loop() {
      if (--counter == 0) { //comparing with 0 should be a bit faster and easier for Arduino to process. Correct me if i am wrong. 
        onOff= !onOff; // changing state of LED
        counter=2; // That digit sets how often your code will be executed. Every 2(3,4... set your own value) iterations of loop().
        // write your code down there, instead of my "digitalWrite(13, onOff);"
        digitalWrite(13, onOff);
        }
}
